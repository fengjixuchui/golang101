<h1>内存块</h1>

<p>
Go是一门支持自动内存管理的语言，比如自动内存开辟和自动垃圾回收。
所以Go程序员在编程时无须进行各种纷繁的内存管理操作。
这不仅给Go程序员提供了很多便利和节省了很多开发时间，而且也帮助Go程序员避免了很多因为疏忽大意而造成的bug。
</p>

<p>
在Go编程中，尽管我们无须知道底层的自动内存管理是如何实现的，但是知道自动内存管理实现中的一些概念和事实对我们写出高质量的Go代码是非常有帮助的。
</p>

<p>
本文将解释和列出标准编译器和运行时中内存块开辟和垃圾回收实现相关的一些概念和事实。
内存管理的其它方面，比如内存申请和内存释放，将不会在本文中探讨。
</p>

<a class="anchor" id="memory-block"></a>
<h3>内存块（memory block）</h3>

<p>
一个内存块是一段在运行时刻承载着若干<a href="value-part.html">值部</a>的连续内存片段。
不同的内存块的大小可能不同，因它们所承载的值部的尺寸而定。
一个内存块同时可能承载着不同Go值的若干值部，但是一个值部在内存中绝不会跨内存块存储，无论此值部的尺寸有多大。
</p>

<div>
一个内存块可能承载若干值部的原因有很多，这里仅列出一部分：
<ul>
<li>
	一个结构体值很可能有若干字段，所以当为此结构体值开辟了一个内存块时，此内存块同时也将承载此结构体值的各个字段值（的直接部分）。
</li>
<li>
	一个数组值常常包含很多元素，所以当为此数组值开辟了一个内存块时，此内存块同时也将承载此数组值的各个元素值（的直接部分）。
</li>
<li>
	两个切片的底层间接部分的元素序列可能承载在同一个内存块上，这两个间接值部甚至可能有部分重叠。
</li>
</ul>
</div>

<h3>一个值引用着承载着它的值部的内存块</h3>

<p>
我们已经知道，一个值部可能引用着另一个值部。这里，我们将引用的定义扩展一下。
我们可以说一个内存块被它承载着的各个值部所引用着。
所以，当一个值部<code>v</code>被另一个值部引用着时，此另一个值部也（间接地）引用着承载着值部<code>v</code>的内存块。
</p>

<a class="anchor" id="when-to-allocate"></a>
<h3>什么时候需要开辟内存块？</h3>

<div>
在Go中，在下列场合（不限于）将发生开辟内存块的操作：
<ul>
<li>
	显式地调用<code>new</code>和<code>make</code>内置函数。
	一个<code>new</code>函数调用总是只开辟一个内存块。
	一个<code>make</code>函数调用有可能会开辟多个内存块来承载创建的切片/映射/通道值的直接和底层间接值部。
</li>
<li>
	使用字面量创建映射、切片或函数值。在此创建过程中，一个或多个内存块将被开辟出来。
</li>
<li>
	声明变量。
</li>
<li>
	将一个非接口值赋给一个接口值。（对于标准编译器来说，不包括将一个指针值赋给一个接口值的情况。）
</li>
<li>
	衔接非常量字符串。
</li>
<li>
	将字符串转换为字节切片或者码点切片，或者反之，除了<a href="string.html#conversion-optimizations">一些编译器优化情形</a>。
</li>
<li>
	将一个整数转换为字符串。
</li>
<li>
	调用内置<code>append</code>函数并且基础切片的容量不足够大。
</li>
<li>
	向一个映射添加一个键值条目并且此映射底层内部的哈希表需要改变容量。
</li>
</ul>

</div>

<a class="anchor" id="where-to-allocate"></a>
<h3>内存块将被开辟在何处？</h3>

<p>
对每一个使用标准编译器编译的Go程序，在运行时刻，每一个协程将维护一个栈（stack）。
一个栈是一个预申请的内存段，它做为一个内存池供某些内存块从中开辟。
在官方Go工具链1.19版本之前，一个栈的初始尺寸总是2KiB。
从1.19版本开始，栈的初始尺寸是<a href="https://docs.google.com/document/d/1YDlGIdVTPnmUiTAavlZxBI1d9pwGQgZT7IKFKlIXohQ">自适应的</a>。
每个栈的尺寸在协程运行的时候将按照需要增长和收缩。
栈的最小尺寸为2KiB。
</p>

<p><i>
（注意：Go运行时维护着一个协程栈的最大尺寸限制，此限制为全局的。
如果一个协程在增长它的栈的时候超过了此限制，整个程序将崩溃。
对于目前的官方标准Go工具链1.19版本，此最大限制的默认值在64位系统上为1GB，在32位系统上为250MB。
我们可以在运行时刻调用<code>runtime/debug</code>标准库包中的<code>SetMaxStack</code>来修改此值。
另外请注意，当前的官方标准编译器实现中，实际上允许的协程栈的最大尺寸为不超过最大尺寸限制的2的幂。
所以对于默认设置，实际上允许的协程栈的最大尺寸在64位系统上为512MiB，在32位系统上为128MiB。）
</i></p>

<p>
内存块可以被开辟在栈上。开辟在一个协程维护的栈上的内存块只能在此协程内部被使用（引用）。
其它协程是无法访问到这些内存块的。
一个协程可以无需使用任何数据同步技术而使用开辟在它的栈上的内存块上的值部。
</p>

<p>
堆（heap）是一个虚拟的概念。每个程序只有一个堆。
一般地，如果一个内存块没有开辟在任何一个栈上，则我们说它开辟在了堆上。
开辟在堆上的内存块可以被多个协程并发地访问。
在需要的时候，对承载在它们之上的值部的访问需要做同步。
</p>

<p>
如果编译器觉察到一个内存块在运行时将会被多个协程访问，或者不能轻松地断定此内存块是否只会被一个协程访问，则此内存块将会被开辟在堆上。
也就是说，编译器将采取保守但安全的策略，使得某些可以安全地被开辟在栈上的内存块也有可能会被开辟在堆上。
</p>

<!--
For the standard Go compiler,
https://docs.google.com/document/d/1CxgUBPlx9iJzkz9JWkb6tIpTe5q32QDmz8l0BouG0Cw/preview

very large memory blocks will always be allocated on heap?
https://github.com/golang/go/issues/20021

The values referenced by values allocated on heap will never be allocated in stacks.
-->

<div>
事实上，栈对于Go程序来说并非必要。Go程序中所有的内存块都可以开辟在堆上。
支持栈只是为了让Go程序的运行效率更高。
<ul>
<li>
	从栈上开辟内存块比在堆上快得多；
</li>
<li>
	开辟在栈上的内存块不需要被垃圾回收；
</li>
<li>
	开辟在栈上的内存块对CPU缓存更加友好。
</li>
</ul>
</div>

<p>
如果一个内存块被开辟在某处（堆上或某个栈上），则我们也可以说承载在此内存块上的各个值部也开辟在此处。
</p>

<p>
如果一个局部声明的变量的某些值部被开辟在堆上，则我们说这些值部以及此局部变量逃逸到了堆上。
我们可以运行Go官方工具链中提供的<code>go build -gcflags -m</code>命令来查看代码中哪些局部值的值部在运行时刻会逃逸到堆上。
如上所述，目前官方Go标准编译器中的逃逸分析器并不十分完美，因此某些可以安全地开辟在栈上的值也可能会逃逸到了堆上。
</p>

<p>
在运行时刻，每一个仍在被使用中的逃逸到堆上的值部肯定被至少一个开辟在栈上的值部所引用着。
如果一个逃逸到堆上的值是一个被声明为<code>T</code>类型的局部变量，则在运行时，一个<code>*T</code>类型的隐式指针将被创建在栈上。
此指针存储着此<code>T</code>类型的局部变量的在堆上的地址，从而形成了一个从栈到堆的引用关系。
另外，编译器还将所有对此局部变量的使用替换为对此指针的解引用。
此<code>*T</code>值可能从今后的某一时刻不再被使用从而使得此引用关系不再存在。
此引用关系在下面介绍的垃圾回收过程中发挥着重要的作用。
</p>

<p>
类似地，我们可以认为每个包级变量（常称全局变量）都被开辟在了堆上，并且它被一个开辟在一个全局内存区上的隐式指针所引用着。
事实上，此指针引用着此包级变量的直接部分，此直接部分又引用着其它的值（部）。
</p>

<p>
一个开辟在堆上的内存块可能同时被开辟在若干不同栈上的值部所引用着。
</p>

<div>
一些事实：
<ul>
<li>
	如果一个结构体值的一个字段逃逸到了堆上，则此整个结构体值也逃逸到了堆上。
</li>
<li>
	如果一个数组的某个元素逃逸到了堆上，则此整个数组也逃逸到了堆上。
</li>
<li>
	如果一个切片的某个元素逃逸到了堆上，则此切片中的所有元素都将逃逸到堆上，但此切片值的直接部分可能开辟在栈上。
</li>
<li>
	如果一个值部<code>v</code>被一个逃逸到了堆上的值部所引用，则此值部<code>v</code>也将逃逸到堆上。
</li>
</ul>
</div>

<p>
使用内置<code>new</code>函数开辟的内存可能开辟在堆上，也可能开辟在栈上。这是与C++不同的一点。
</p>

当一个协程的栈的大小（因为栈增长或者收缩而）改变时，一个新的内存段将申请给此栈使用。
原先已经开辟在老的内存段上的内存块将很有可能被转移到新的内存段上，或者说这些内存块的地址将改变。
相应地，引用着这些开辟在此栈上的内存块的指针（它们同样开辟在此栈上）中存储的地址也将得到刷新。
下面是一个展示开辟在栈上的值的地址改变的例子。

<pre class="line-numbers"><code class="language-go">package main

func f(i int) byte {
	type _ int // 防止f被内联
	var a [1<<20]byte // 使栈增长
	return a[i]
}

func main(){
	var x int
	println(&x)
	f(100)
	println(&x)
}
</code></pre>

<p>
我们可以看到，上例打引出的两个地址不一样（如果使用官方标准编译器v1.19编译之）。
</p>

<!--p>
另一个我们需要知道的重要事实是，为了让64位整数的原子操作在32位架构上成为可能，任何开在堆上的内存块的起始地址都保证是8字节对齐的。
</p-->

<a class="anchor" id="when-can-collect"></a>
<h3>一个内存块在什么条件下可以被回收？</h3>

<p>
为包级变量的直接部分开辟的内存块永远不会被回收。
</p>

<p>
每个协程的栈将在此协程退出之时被整体回收，此栈上开辟的各个内存块没必要被一个一个单独回收。
栈内存池并不由垃圾回收器回收。
</p>

<p>
对一个开在堆上的内存块，当它不再被任何开辟在协程栈的仍被使用中的，以及全局内存区上的，值部所（直接或者间接）地引用着，则此内存块可以被安全地垃圾回收了。
我们称这样的内存块为不再被使用的内存块。开辟在堆上的不再被使用的内存块将在以后某个时刻被垃圾回收器回收掉。
</p>

<div>
下面是一个展示了一些内存块在何时可以被垃圾回收的例子。

<pre class="line-numbers"><code class="language-go">package main

var p *int

func main() {
	done := make(chan bool)
	// done通道将被使用在主协程和下面将要
	// 创建的新协程中，所以它将被开辟在堆上。

	go func() {
		x, y, z := 123, 456, 789
		_ = z  // z可以被安全地开辟在栈上。
		p = &x // 因为x和y都会将曾经被包级指针p所引用过，
		p = &y // 因此，它们都将开辟在堆上。

		// 到这里，x已经不再被任何其它值所引用。或者说承载
		// 它的内存块已经不再被使用。此内存块可以被回收了。

		p = nil
		// 到这里，y已经不再被任何其它值所引用。
		// 承载它的内存块可以被回收了。

		done <- true
	}()

	<-done
	// 到这里，done已经不再被任何其它值所引用。一个
	// 聪明的编译器将认为承载它的内存块可以被回收了。

	// ...
}
</code></pre>

<p>
</p>

有时，聪明的编译器可能会做出一些出人意料的（但正确的）的优化。
比如在下面这个例子中，切片<code>bs</code>的底层间接值部在<code>bs</code>仍在使用之前就已经被标准编译器发觉已经不再被使用了。

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	// 假设此切片的长度很大，以至于它的元素
	// 将被开辟在堆上。
	bs := make([]byte, 1 << 31)

	// 一个聪明的编译器将觉察到bs的底层元素
	// 部分已经不会再被使用，而正确地认为bs的
	// 底层元素部分在此刻可以被安全地回收了。

	fmt.Println(len(bs))
}
</code></pre>

<p>
关于切片值的内部实现结构，请参考<a href="value-part.html">值部</a>一文。
</p>

<p>
顺便说一下，有时候出于种种原因，我们希望确保上例中的<code>bs</code>切片的底层间接值部不要在<code>fmt.Println</code>调用之前被垃圾回收。
这时，我们可以使用一个<code>runtime.KeepAlive</code>函数调用以便让垃圾回收器知晓在此调用之前切片<code>bs</code>和它所引用着的值部仍在被使用中。
</p>

一个例子：

<pre class="line-numbers"><code class="language-go">package main

import "fmt"
import "runtime"

func main() {
	bs := make([]int, 1000000)

	fmt.Println(len(bs))
	runtime.KeepAlive(&bs)
	// 对于这个特定的例子，也可以调用
	// runtime.KeepAlive(bs)。
}
</code></pre>

<p>
</p>

</div>

<a class="anchor" id="how-to-detect"></a>
<h3>如何判断一个堆内存块是否仍在被使用？</h3>

<div>
<p>
目前的官方Go标准运行时（1.19版本）使用<a href="https://blog.golang.org/go15gc">一个并发三色（tri-color）标记清扫（mark-sweep）算法</a>来实现垃圾回收。
这里仅会对此算法的原理做一个大致的描述。一个具体实现可能和此大致描述会有很多细节上的差别。
</p>

<p>
一个垃圾回收过程分为两个阶段：标记阶段和清扫阶段。
</p>

在标记阶段，垃圾回收器（实际上是一组协程）使用三色算法来分析哪些（开辟在堆上的）内存块已经不再使用了。
<ul>
<li>
	在每一轮（见下一节的解释）垃圾回收过程的开始，所有的堆内存块将被标记为白色。
</li>
<li>
	然后垃圾回收器将所有开辟在栈和全局内存区上的内存块标记为灰色，并把它们加入一个灰色内存块列表。
</li>
<li>
	循环下面两步直到灰色内存块列表为空：
	<ol>
	<li>
		从个灰色内存块列表中取出一个内存块，并把它标记为黑色。
	</li>
	<li>
		然后扫描承载在此内存块上的指针值，并通过这些指针找到它们引用着的内存块。
		如果一个引用着的内存块为白色的，则将其标记为灰色并加入灰色内存块列表；否则，忽略之。
	</li>
	</ol>
</li>
</ul>

<p><i>
（注意这里在算法中使用三色而不是两色的原因是此标记过程是并发的。在标记的过程中，很多其它普通用户协程也正在运行中。
在此标记过程中对指针的写入需要一些额外的开销，欲更深入了解此点，请以“write barrier golang”为关键字自行搜索以深入了解。
简而言之，当在某个用户协程中，一个已经标记为黑色的内存块在标记过程中被修改而使其新引用着的一个仍标记为白色的内存块时，此白色内存块需要被标记为灰色，否则此白色内存块有可能将被认为是垃圾而回收掉；除此之外的情况不做特殊处理。）
</i></p>

<p>
在清扫阶段，仍被标记为白色的内存块将被认为不再使用而被回收掉。
</p>

<p>
一个不再被使用的内存块被回收后可能并不会立即释放给操作系统，这样Go运行时可以将其重新分配给其它值部使用。
不用担心，官方Go运行时的实现比大多数主流的Java运行时要消耗少得多的内存。
</p>

<p>
此垃圾回收算法不会移动内存块来整理内存碎片。
</p>
</div>

<a class="anchor" id="when-to-collect"></a>
<h3>不再被使用的内存块将在什么时候被回收？</h3>

<div>

<p>
垃圾回收过程将消耗相当的CPU资源和一些内存资源。所以垃圾回收过程并非总在运行。
一个新的垃圾回收过程将在程序运行中的某些实时指标达到某些条件时才会被触发。
这些条件怎么定义的是一个垃圾回收调度问题。
</p>

官方标准运行时（runtime）的垃圾回收调度实现仍在随着版本递增而在不断地改善中。
所以很难精确地描述此实现并同时保证描述的长期有效性。这里，我仅仅列出一些相关的参考文献：

<ul>
<li>
	关于<a href="https://golang.org/pkg/runtime/#hdr-Environment_Variables"><code>GOGC</code>和<code>GOMEMLIMIT</code>环境变量</a>（注意<code>GOMEMLIMIT</code>环境变量从Go 1.19开始才支持）；
</li>
<li>
	<a href="https://go.dev/doc/gc-guide">A Guide to the Go Garbage Collector</a>；
</li>
<li>
	<a href="https://github.com/golang/proposal/blob/master/design/44167-gc-pacer-redesign.md">GC Pacer Redesign</a>；
</li>
<li>
	我的<a href="https://gfw.go101.org/optimizations/101.html">Go编程优化101</a>一书中的“垃圾回收”一章（此书中文版目前尚未发布，<a href="https://go101.org/optimizations/101.html">英文版</a>可付费购买）。
</li>
</ul>

<!--
<p>
开辟在堆上的不再使用的内存块将被Go运行时认为是垃圾而将被回收，以供以后重用或者释放（给操作系统）。
垃圾回收器并不是时刻都在运行着。它只是每隔一段时间因为某些条件达成之后才开始新的一轮垃圾回收过程。
所以，一个不再被使用的内存块不会在它不再使用后立即得到回收，而是将在一段时间后被逐步回收。
</p>

<p>
目前（Go官方工具链1.19），对于使用标准编译器编译的Go程序，一轮新的垃圾回收过程开启的默认条件是通过<a href="https://golang.google.cn/pkg/runtime/#hdr-Environment_Variables"><code>GOGC</code>环境变量</a>来控制的。
当从上一轮垃圾回收结束后新申请的内存块的内存总和占上一轮垃圾回收结束时仍在被使用的所有内存块的内存总和的百分比超过此值时，新的一轮垃圾回收过程将开始。
所以此值决定了垃圾回收过程的频率。
此环境变量的默认值为100。
此值也可以通过调用<a href="https://golang.google.cn/pkg/runtime/debug/#SetGCPercent"><code>runtime/debug.SetGCPercent</code>函数</a>在运行时刻被动态地修改。
调用<code>debug.SetGCPercent(-1)</code>将关闭自动垃圾回收。
</p>

<p>
Go官方工具链1.19引入了一种新的垃圾回收启动策略：<a href="https://go.dev/doc/gc-guide#Memory_limit">内存使用限制策略</a>。
此策略可以通过设置<code>GOMEMLIMIT</code>环境变量或者调用<a href="https://golang.org/pkg/runtime/debug/#SetMemoryLimit">runtime/debug.SetMemoryLimit</a>函数来配置。
此内存限制设置了Go运行时（runtime）应该使用的最大内存值。
换句话说，如果运行时使用的内存超过了此限制，一轮新的垃圾回收过程将开启（这是一个软限制，Go程序不会因此而退出）。
此限制的默认值为<code>math.MaxInt64</code>，这事实上是禁止了此策略发挥作用。
请注意，如果此限制被设置为一个不够充分大的值，则垃圾回收过程将会很频繁的启动（但即使这样的情况发生，垃圾回收过程消耗的CPU资源一般也不会超过50%）。
</p>

<p>
一轮新的垃圾回收过程也可以通过调用<a href="https://golang.google.cn/pkg/runtime/#GC"><code>runtime.GC</code>函数</a>来手动开启。
</p>

<p>
另一点需要注意的是，当前的官方Go运行时（v1.19）同时采取了另一个策略：<a href="https://github.com/golang/go/blob/895b7c85addfffe19b66d8ca71c31799d6e55990/src/runtime/proc.go#L4481-L4486">一个Go程序的最大垃圾回收时间间隔为两分钟</a>。
</p>

<p>
当前支持的几种垃圾回收启动策略都不能完美应对所有应用场景，所以以后的Go运行时版本可能会采取和支持更多不同的垃圾回收启动策略。
</p>
-->

</div>

